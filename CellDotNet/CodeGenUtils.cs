using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Reflection;
using System.Text;
using Mono.Cecil.Cil;
using NUnit.Framework;

namespace CellDotNet
{
	[TestFixture, Ignore("Only for generating code.")]
	public class CodeGenUtils
	{
		[Test]
		public void GenerateILFlowNextOpCodeSwitchCases()
		{
			TextWriter sw = Console.Out;
			FieldInfo[] fields = typeof (OpCodes).GetFields();

			foreach (FieldInfo fi in fields)
			{
				if (fi.FieldType != typeof(OpCode))
					continue;

				OpCode oc = (OpCode) fi.GetValue(null);
				if (oc.FlowControl != FlowControl.Next)
					continue;

				if (oc.OpCodeType == OpCodeType.Macro)
					continue;

				sw.Write("\t\t\tcase Code.{0}: // {1}\r\n", oc.Code, oc.Name);
			}
		}


		/// <summary>
		/// Returns the SPU opcodes that are defined and checks that their field names are the same as the name that is given to the constructor.
		/// </summary>
		/// <returns></returns>
		private static List<SpuOpCode> GetSpuOpCodes()
		{
			FieldInfo[] fields = typeof (SpuOpCode).GetFields(BindingFlags.Static | BindingFlags.Public);

			List<SpuOpCode> opcodes = new List<SpuOpCode>();

			foreach (FieldInfo field in fields)
			{
				if (field.FieldType != typeof(SpuOpCode))
					continue;

				SpuOpCode oc = (SpuOpCode) field.GetValue(null);

				if (oc.Name != field.Name)
					throw new Exception(string.Format("Name of opcode field {0} is not the same as the opcode name ({1}).", field.Name, oc.Name));

				opcodes.Add(oc);
			}

			return opcodes;
		}

		/// <summary>
		/// Returns the qualified name of the static field that contains the field. 
		/// Used for generating the instruction writer methods.
		/// </summary>
		static string GetQualifiedOpcodeFieldName(SpuOpCode opcode)
		{
			return typeof (SpuOpCode).Name + "." + opcode.Name;
		}

		[Test]
		public void GenerateSpuInstructionWriterMethods()
		{
			StringWriter tw = new StringWriter();

			tw.Write(@"
	// THIS CLASS IS GENERATED BY {0}.{1} - DO NO EDIT. 
	partial class {2}
	{{
", GetType().FullName, "GenerateSpuInstructionWriterMethods()", typeof(SpuInstructionWriter).Name);

			List<SpuOpCode> list = GetSpuOpCodes();
			foreach (SpuOpCode opcode in list)
			{
				// capitalized name.
				string ocname = opcode.Name[0].ToString().ToUpper() + opcode.Name.Substring(1);

				bool noRegisterWriteIsHandled = false;
				switch (opcode.Format)
				{
					case SpuInstructionFormat.None:
						break;
					case SpuInstructionFormat.RR:
						noRegisterWriteIsHandled = true;
						if (opcode.NoRegisterWrite)
						{
							tw.Write(@"
		/// <summary>
		/// {2}
		/// </summary>
		public void Write{0}(VirtualRegister ra, VirtualRegister rb, VirtualRegister rt)
		{{
			WriteRR({1}, ra, rb, rt);
		}}
", ocname, GetQualifiedOpcodeFieldName(opcode), opcode.Title);
							
						}
						else
						{
							tw.Write(@"
		/// <summary>
		/// {2}
		/// </summary>
		public VirtualRegister Write{0}(VirtualRegister ra, VirtualRegister rb)
		{{
			return WriteRR({1}, ra, rb);
		}}
", ocname, GetQualifiedOpcodeFieldName(opcode), opcode.Title);

						}

						break;
					case SpuInstructionFormat.RR2:
						tw.Write(@"
		/// <summary>
		/// {2}
		/// </summary>
		public VirtualRegister Write{0}(VirtualRegister ra)
		{{
			return WriteRR2({1}, ra);
		}}
", ocname, GetQualifiedOpcodeFieldName(opcode), opcode.Title);
						break;
					case SpuInstructionFormat.RR1:
						tw.Write(@"
		/// <summary>
		/// {2}
		/// </summary>
		public VirtualRegister Write{0}()
		{{
			return WriteRR1({1});
		}}
", ocname, GetQualifiedOpcodeFieldName(opcode), opcode.Title);
						break;
					case SpuInstructionFormat.RR1DE:
						// Currently no D, E bit support.
						tw.Write(@"
		/// <summary>
		/// {2}
		/// </summary>
		public void Write{0}(VirtualRegister ra)
		{{
			WriteRR1DE({1}, ra);
		}}
", ocname, GetQualifiedOpcodeFieldName(opcode), opcode.Title);
						break;
					case SpuInstructionFormat.RR2DE:
						// Currently no D, E bit support.
						tw.Write(@"
		/// <summary>
		/// {2}
		/// </summary>
		public VirtualRegister Write{0}(VirtualRegister ra)
		{{
			return WriteRR2DE({1}, ra);
		}}
", ocname, GetQualifiedOpcodeFieldName(opcode), opcode.Title);
						break;
					case SpuInstructionFormat.RRR:
						tw.Write(@"
		/// <summary>
		/// {2}
		/// </summary>
		public VirtualRegister Write{0}(VirtualRegister ra, VirtualRegister rb, VirtualRegister rc)
		{{
			return WriteRRR({1}, ra, rb, rc);
		}}
", ocname, GetQualifiedOpcodeFieldName(opcode), opcode.Title);
						break;
					case SpuInstructionFormat.RI7:
						tw.Write(@"
		/// <summary>
		/// {2}
		/// </summary>
		public VirtualRegister Write{0}(VirtualRegister ra, int value)
		{{
			return WriteRI7({1}, ra, value);
		}}
", ocname, GetQualifiedOpcodeFieldName(opcode), opcode.Title);
						break;
					case SpuInstructionFormat.RI8:
						tw.Write(@"
		/// <summary>
		/// {2}
		/// </summary>
		public VirtualRegister Write{0}(VirtualRegister ra, int scale)
		{{
			return WriteRI8({1}, ra, scale);
		}}
", ocname, GetQualifiedOpcodeFieldName(opcode), opcode.Title);
						break;
					case SpuInstructionFormat.RI10:
						noRegisterWriteIsHandled = true;
						if (opcode.NoRegisterWrite)
						{
							tw.Write(@"
		/// <summary>
		/// {2}
		/// </summary>
		public void Write{0}(VirtualRegister ra, VirtualRegister rt, int value)
		{{
			WriteRI10Sourced({1}, ra, rt, value);
		}}
", ocname, GetQualifiedOpcodeFieldName(opcode), opcode.Title);
						}
						else
						{
							tw.Write(@"
		/// <summary>
		/// {2}
		/// </summary>
		public VirtualRegister Write{0}(VirtualRegister ra, int value)
		{{
			return WriteRI10({1}, ra, value);
		}}
", ocname, GetQualifiedOpcodeFieldName(opcode), opcode.Title);
						}
						break;
					case SpuInstructionFormat.RI16:
						noRegisterWriteIsHandled = true;
						if (opcode.NoRegisterWrite)
						{
							tw.Write(@"
		/// <summary>
		/// {2}
		/// </summary>
		public void Write{0}(VirtualRegister rt, int symbol)
		{{
			WriteRI16Sourced({1}, rt, symbol);
		}}
", ocname, GetQualifiedOpcodeFieldName(opcode), opcode.Title);
						}
						else
						{
							tw.Write(@"
		/// <summary>
		/// {2}
		/// </summary>
		public VirtualRegister Write{0}(int symbol)
		{{
			return WriteRI16({1}, symbol);
		}}
", ocname, GetQualifiedOpcodeFieldName(opcode), opcode.Title);
						}

						break;
					case SpuInstructionFormat.RI16x:
						tw.Write(@"
		/// <summary>
		/// {2}
		/// </summary>
		public void Write{0}(int symbol)
		{{
			WriteRI16x({1}, symbol);
		}}
", ocname, GetQualifiedOpcodeFieldName(opcode), opcode.Title);
						break;
					case SpuInstructionFormat.RI18:
						tw.Write(@"
		/// <summary>
		/// {2}
		/// </summary>
		public VirtualRegister Write{0}(int symbol)
		{{
			return WriteRI18({1}, symbol);
		}}
", ocname, GetQualifiedOpcodeFieldName(opcode), opcode.Title);
						break;
					case SpuInstructionFormat.WEIRD:
						// Needs custom methods.
						noRegisterWriteIsHandled = true;
						break;
					default:
						throw new Exception("Invalid instruction format: " + opcode.Format);
				}

				if (opcode.NoRegisterWrite && !noRegisterWriteIsHandled)
					throw new Exception("opcode.NoRegisterWrite not handled for opcode " + opcode.Name + ".");
			}

			tw.Write(@"
	}
");

			Console.Write(tw.GetStringBuilder().ToString());
		}

	}

}
